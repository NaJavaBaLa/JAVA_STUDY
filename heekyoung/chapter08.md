# Chatper08. 인터페이스
<hr/>

## 8.1 인터페이스의 역할
인터페이스(interface) : 객체의 사용 방법을 정의한 타입<br>
인터페이스는 여러 객체들과 사용 가능하기 때문에 어떤 객체를 사용하느냐에 따라 실행 내용과 리턴값이 달라짐

## 8.2 인터페이스 선언
### 8.2.1 인터페이스 선언
- interface 클래스명
- 상수와 메소드만 구성멤버
- 인터페이스는 객체로 생성할 수 없기 때문에 생성자를 가질 수 없음
- 자바 8버전 부터는 추상 메소드 뿐만 아니라 디폴트 메소드와 정적 메소드도 선언 가능 함

**상수 필드(Constant Field)** <br>
- 인터페이스에 고정된 값으로 런타임 될 때 데이터를 바꿀 수 없음 -> 상수 선언 시 반드시 초기값을 대입해야 함<br>

**추상 메소드(Abstract Method)**<br>
- 객체가 가지고 있는 메소드를 설명한 것 -> 어떤 매개값이 필요하고 리턴 타입이 무엇인지 알려줌<br>
- 실제 실행부는 객체(구현 객체)가 가지고 있음<br>

**디폴드 메소드(Default Method)**<br>
- 인터페이스에 선언되지만 사실은 객체(구현 객체)가 가지고 있는 인스턴스 메소드라고 생각 해야 함<br>
- 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해 8버전 부터 허용 함<br>

**정적 메소드(Static Method)**<br>
- 디폴트 메소드와 다르게 객체가 없어도 인터페이스만으로 호출 가능<br>

### 8.2.2 상수 필드 선언<br>
- 상수 필드만 선언 가능
- 상수는 public static final로 선언 => 생략해도 컴파일 과정에서 자동으로 붙음

### 8.2.3 추상 메소드 선언<br>
추상 메소드 : 리턴타입, 메소드명, 매개 변수만 기술 되고 중괄호 {}를 붙이지 않은 메소드<br>
추상메소드는 모두 public abstract 특성을 가짐

### 8.2.4 디폴트 메소드 선언
- 디폴트 메소드는 public 특성을 갖기 때문에 public을 생략하더라도 컴파일 과정에서 자동적으로 붙음

### 8.2.5 정적 메소드 선언
- public 특성을 갖기 때문에 생략해도 컴파일 과정에서 자동으로 붙음

## 8.3 인터페이스 구현
인터페이스 구현(implements) 객체 : 인터페이스에서 정의된 추상 메소드와 동일한 메소드 이름, 매개타입, 리턴 타입을 가진 실체 메소드<br>
구현 클래스 : 구현 객체를 생성하는 클래스

### 8.3.1 구현 클래스
- implements 키워드룰 추가하고 인터페이스명 명시
- 인터페이스에 선언된 추상 메소드의 실체 메소드를 선언해야 함
- public 보다 더 낮은 접근제한으로 작성 불가능
- 인터페이스에 선언된 추상 메소드를 구현 클래스가 작성하지 않으면 구현 클래스는 자동으로 추상 클래스가 됨

### 8.3.2 익명 구현 객체
- 중괄호 안에 인터페이스에 선언된 모든 추상 메소드들의 실체 메소드를 작성해야 한다.

```java
public class RemoteControlExcample{
	public static main (String[] args) {
	//익명 구현 객체
		RemoteControl rc = new RemoteControl() {
			public void turnOn() { 구현 }
			public void trunOff() { 구현 }
			public void setVolume(int volume) { 구현 }
		};
	}
}
```

컴파일 하면 자동으로 RemoteControlExample.java의 클래스 파일이 생성 됨

### 8.3.3 다중 인터페이스 구현 클래스
- 다중 인터페이스를 구현할 경우, 구현 클래스는 모든 인터페이스의 추상 메소드에 대해 실체메소드를 작성해야 함
- 하나라도 없으면 추상 메소드로 선언해야 한다.

## 8.4 인터페이스 사용
- 인터페이스 변수는 참조 타입이기 때문에 구현 객체가 대입될 경우 구현 객체의 번지를 저장함

```java
RemoteControl rc; //RemoteConotrol 인터페이스를 타입 변수 rc를 선언하고
rc = new Television(); //구현 객체를 대입해야 함
rc = new Audio();
```

### 8.4.1 추상 메소드 사용
- 구현 객체가 인터페이스 타입에 대입되면 인터페이스에 선언된 추상메소드를 호출 할 수 있음

### 8.4.2 디폴트 메소드 사용
- 디폴트 메소드는 인터페이스에 선언되지만 인터페이스에서 바로 사용 할 수 없음
- 디폴트 메소드를 오버라이딩해서 자신에게 맞게 수정하면 자신이 재정의한 메소드가 호출 됨
- 디폴트 메소드는 인스턴스 메소드이기 때문에 구현 객체가 있어야 사용 가능함

```java
//이렇게 사용 할 수 없음
RemoteControl.setMute(true);

///이렇게 사용해야 함
RemoteControl rc = new Television();
rc.setMute(true);
```

### 8.4.3 정적 메소드 사용
- 정적 메소드는 인터페이스로 바로 호출 가능


## 8.5 타입 변환과 다형성
상속은 같은 종류의 하위 클래스를 생성하는 것<br>
인터페이스는 사용 방법이 동일한 클래스를 생성하는 것<br>
둘 다 다형성을 구현<br>

### 8.5.1 자동 타입 변환(Promotion)
자동 타입 변환(Promotion) : 구현 객체가 인터페이스 타입으로 변환되는 것 <br>
프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것임 <br>

### 8.5.2 필드의 다형성

### 8.5.3 인터페이스 배열로 구현 객체 관리

### 8.5.4 매개 변수의 다형성
- 매개 변수 타입이 인터페이스일 경우, 어떠한 구현 객체도 매개값으로 사용 가능함

### 8.5.5 강제 타입 변환(Casting)
- 구현 객체가 인터페이스 타입으로 자동 타입 변환 되면 인터페이스에 선언된 메소드만 사용 가능함
- 구현 클래스에 선언된 필드와 메소드를 사용하고 싶은 경우 강제 타입 변환 해서 다시 구현 클래스 타입으로 변환 함

### 8.5.6 객체 타입 확인(instance of)
- instance of 연산자로 확인후 강제 타입 변환 해야 함

## 8.6 인터페이스 상속
- 인터페이스도 다른 인터페이스를 상속할 수 잇음
- 인터페이스는 다중 상속을 허용 함
- 하위 인터페이스를 구현하는 클래스는 하위 인터페이스 뿐만 아니라 상위 인터페이스의 모든 추상 메소드에 대한 실체 메소드를 가지고 있어야 함
  => 그렇기 때문에 구현 클래스로부터 객체를 생성하고 나서 하위 및 상위 인터페이스 타입으로 변환이 가능하다.
- 하위 인터페이스로 타입 변환이 되면 상,하위 인터페이스의 메소드를 전부 사용 가능하지만 상위 인터페스로 타입 변환되면 상위 인터페이스의 메소드만 사용 가능

## 8.7 디폴트 메소드와 인터페이스 확장
- 디폴트 메소드는 인터페이스에 선언된 인스턴스 메소드이기 때문에 구현 객체가 있어야 사용 가능 함

### 8.7.1 디폴트 메소드의 필요성
- 기존에 있는 인터페이스와 그것을 구현한 클래스에 새로운 추상 메소드를 추가 할 경우 기존에 구현해야 하는 클래스에서 문제가 발생 함
  => 추상 메소드일 경우 그것을 구현한 기존 클래스에도 새로운 추상 메소드를 구현해야 함<br>
     그런데 디폴트 메소드는 추상 클래스가 아니기 때문에 굳이 실체 메소드를 구현할 필요가 없어서 기존의 클래스를 계속 사용 가능함<br>
     기존 인터페이스에 default 메소드를 추가하여 이를 구현하는 새로운 클래스를 생성해서 쓰면 됨

### 8.7.2 디폴트 메소드가 있는 인터페이스 상속
*부모 인터페이스에 디폴트 메소드가 정의되어 있을 경우, 자식 인터페이스에서 디폴트 메소드를 활용하는 방법
1. 디폴트 메소드를 단순히 상속만 받음
2. 디폴트 메소드를 오버라이드해서 실행 내용을 변경
3. 디폴트 메소드를 추상 메소드로 재선언
