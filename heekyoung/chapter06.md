# Chapter06. 클래스
<hr/>

## 6.1 객체 지향 프로그래밍
객체 지향 프로그래밍(OPP : Object Oriented Programming) : 객체들을 먼저 만들고 하나씩 조립해서 완성된 프로그램을 만드는 기법

### 6.1.1 객체란?
객체(Object) : 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것<br>
ex) 물리적으로 존재하는 것 : 자동차, 자전거, 책, 사람, 추상적인 학과, 강의 주문 등<br>
			  속성(=필드)과 동작(=메소드)으로 구성<br>
객체 모델링(Object Modeling) : 현실세계의 객체를 소프트웨어 객체로 설계하는 것

### 6.1.2 객체의 상호작용
객체는 각각 독립적이고 다른 객체와 서로 상호작용 함<br>
=> 상호작용 수단이 메소드<br>
매개값 : 메소드를 실행하기 위해 필요한 데이터<br>
리턴값 : 메소드가 실행하고 나서 호출한 곳으로 돌려주는 값

### 6.1.3 객체 간의 관계
객체 간의 관계 종류 : 집합 관계, 사용 관계, 상속 관계<br>
- 집합관계 : 집합 관계에 있는 객체는 하나는 부품이고 하나는 완성품에 해당
- 사용관계 : 객체 간의 상호작용 <br>
- 상속관계 : 상위(부모)객체를 기반으로 하위(자식)객체를 생성하는 관계

### 6.1.4 객체 지향 프로그래밍의 특징
**캡슐화(Encapsulation)** <br>
- 객체의 필드, 메소드를 하나로 묶고 실제 구현 내용을 감추는 것<br>
 => 외부 객체는 객체 내부 구조를 알지 못하고 객체가 노출해서 제공하는 필드와 메소드만 이용 가능<br>
 - 외부의 잘못된 사용으로 인해 객체를 손상되지 않도록 하기 위해 캡슐화 사용<br>
 - 접근제한자를 사용해 객체의 필드와 메소드의 사용 범위를 제한<br>
 
**상속(Inheritance)**<br>
 상위 객체가 가지고 있는 필드와 메소드를 하위 객체에게 물려줘 하위 객체가 사용할 수 있도록 하는 것
 
**다형성(Polymorphism)** <br>
 - 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질 <br>
 - 하나의 타입에 여러 객체를 대입함으로 다양한 기능을 이용 할 수 있음<br>
 - 다형성을 위해 부모 클래스나 인터페이스의 타입 변환 허용<br>



## 6.2 객체와 클래스
 클래스 : 객체를 생성하기 위한 필드와 메소드가 정의 <br>
 => 클래스로부터 만들어진 객체를 클래스의 인스턴스(instance)라고 함 => 이 과정이 인스턴스화
 
## 6.3 클래스 선언
클래스 식별자 작성 규칙
1. 하나 이상의 문자로 이루어져야 함
2. 첫 번째 글자는 숫자가 올 수 없음
3. '$','_' 이외의 특수 문자 불가
4. 자바 키워드 사용 불가

각 단어의 첫 머리 글자는 대문자로 작성하는 것이 관례 <br>
파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있음<br>

## 6.4 객체 생성과 클래스 변수
객체 생성 방법 : new 연산자 => 메모리 힙(heap) 영역에 생성<br>

```java
클래스 변수;
변수 = new 클래스();

클래스 변수 = new 클래스();
```
클래스의 용도 <br>
1. 라이브러리(API)용 <br>
=> 다른 클래스에서 이용할 목적
2. 실행용

## 6.5 클래스의 구성 멤버
필드(Field), 생성자(Constructor), 메소드(Method)

```java
public class ClassName{
	// 필드 : 객체의 데이터가 저장되는 곳
	int fieldName;

	//생성자 : 객체 생성시 초기화 역할 담당
	ClassName(){ }
	
	//메소드 : 객체의 동작에 해당하는 실행 블록
	void methodName(){ }
}
```

### 6.5.1 필드
- 변수와 다른 점 : 변수는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 실행 종료되면 자동 소멸 됨 <br>
				하지만 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재 함

### 6.5.2 생성자
- new 연산자로 호출
- 객체 생성시 초기화 담당
- 필드를 초기화 하거나, 메소드를 호출해서 객체를 사용할 준비 함
- 클래스 이름으로 되어있고 리턴 타입이 없음

### 6.5.3 메소드
- 객체의 동작


## 6.6 필드
객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장하는 곳

### 6.6.1 필드 선언
- 생성자와 메소드 중괄호 블록 내부에서는 선언 불가능 => 여기서 선언 되면 로컬 변수임
- 타입은 기본타입과 참조 타입 모두 사용 가능

### 6.6.2 필드 사용
클래스 내부 : 필드 이름 읽고 변경 가능<br>
클래스 외부 : 클래스로부터 객체 생성한 뒤 필드 사용


## 6.7 생성자
- 객체를 생성할 때 호출되어 객체의 초기화를 담당
- 생성자를 실행시키지 않고는 클래스로 부터 객체 생성 불가능
- new 연산자에 의해 생성자가 성공적으로 실행되면 힙 여영ㄱ에 생성되고 객체의 주소가 리턴 됨

### 6.7.1 기본 생성자
- 모든 클래스는 생성자가 반드시 존재하고 하나 이상을 가질 수 있음
- 생성자 선언을 생략하면 컴파일러는 기본 생성자를 바이트 코드에 자동 추가 함
  => 명시적으로 선언한 생성자가 하나라도 있으면 기본 생성자를 추가하지 않음
  
### 6.7.2 생성자 선언
- 리턴 타입이 없고 클래스 이름과 동일

### 6.7.3 필드 초기화
클래스를 작성할 때나 매개값으로 받아 초기화 가능

### 6.7.4 생성자 오버로딩(Overloading)
생성자 오버로딩 : 매개변수를 달리하는 생성자를 여러 개 선언하는 것

```java
public Class Car{
	Car(){ }
	Car(String model) { }
	Car(String model1, String model2) { }
}
```

- 매개변수의 타입과 개수, 선언된 순서가 똑같을 경우 오버로딩이 아님
- new 연산자를 호출할 때 제공되는 매개값의 타입과 수에 의해 호출될 생성자 결정

### 6.7.5 다른 생성자 호출(this())
- 매개 변수의 수만 달르고 필드 초기화 내용이 비슷한 생성자에서 많이 사용

```java
public class Car{
// 필드
String company - "현대자동차";
String model;
String color;
int maxSpeed;

//생성자
Car() {
}

Car(String model) {
	this(model, "은색", 250);
}

Car(String model, String color) {
	this(model, color, 250);
}

Car(STring model, String color, int maxSpeed) {
	this.model = model;
	this.color = color;
	this.maxSpeed = maxSpeed;
	}
}

```

## 6.8 메소드
### 6.8.1 메소드 선언
선언부 : 리턴타입, 메소드 이름, 매개변수 선언과 실행블록을 구성

**리턴타입** <br>
메소드가 실행 한 후 리턴하는 값의 타입<br>
리턴 값이 있는 메소드는 리턴값의 타입이 와야 함

**메소드이름** <br>
- 숫자로 오면 안되고 $와 _ 를 제외한 특수문자 사용 불가능
- 메소드명은 소문자
- 서로 다른 단어가 혼합되면 camel case로 작성

**매개 변수 선언**
- 매개 변수의 타입에 부합되는 값을 넣어야 함

**매개 변수의 수를 모를 경우**
- 배열 타입으로 선언

### 6.8.2 리턴(return)문
**리턴값이 있는 메소드**
- 메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴값을 지정해야 함

**리턴 값이 없는 메소드**
- void로 선언된 리턴 값이 없는 메소드에서도 return문 사용 가능
- return문 사용시 메소드 실행을 강제 종료

### 6.8.3 메소드 호출
**객체 내부에서 호출** <br>
메소드(매개값, ... );

**객체 외부에서 호출** <br>
클래스로부터 객체 생성<br>
클래스 참조변수 = new 클래스(매개값, ... );

### 6.8.4 메소드 오버 로딩
메소드 오버로딩(Method overloading) : 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것
-> 매개 변수의 타입, 개수, 순서가 달라야 함

## 6.9 인스턴스 멤버와 변수
인스턴스(instance) 멤버 : 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드<br>
객체는 자신을 this라고 함<br>
주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용

## 6.10 정적 멤버와 static
정적(static) : 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드

### 6.10.1 정적 멤버 선언
인스턴스 필드로 선언할 것인가? 정적 필드로 선언할 것인가? <br>
 => 객체마다 가지고 있어야 할 데이터는 인스턴스 필드, 객체마다 가지고 있을 필요성이 없는 공용적인 데이터라면 정적 필드로 선언<br>
 인스턴스 메소드로 선언할 것인가? 정적 메소드로 선언할 것인가?<br>
 => 인스턴스 필드를 이용해 실행해야 한다면 인스턴스 메소드로 선언, 인스턴스 필드를 이용하지 않는다면 정적 메소드로 선언
 
### 6.10.2 정적 멤버 사용
정적 요소는 클래스 이름으로 접근하는 것이 좋다.

### 6.10.3 정적 초기화 블록
정적 필드는 필드 선언과 동시에 초기값을 주는 것이 보통임
```java
public class Television{
	static String company = "Samsung";
	static String model = "LCD";
	static String info;
	
	static {
		info = company + "-" + model;
	}
}
```
### 6.10.4 정적 메소드와 블록 선언 시 주의할 점
- 객체가 없어도 실행되기 때문에 내부에 인스턴스 ㅍ리드나 인스턴스 메소드를 사용할 수 없음
- this 키워드도 사용 불가
- 정적 메소드와ㅏ 정적 블록에서 인스턴스 멤버를 사용하고 싶다면 객체를 먼저 생성하고 참조 변수로 접근해야 함
```java
static void Method3() {
	ClassName obj = new ClassName();
	obj.field1 = 10;
	obj.method1();
}
```

### 6.10.5 싱글톤(Singleton)
싱글톤 : 단 하나의 객체만 만들도록<br>
- 싱글톤을 만드려면 클래스 외부에서 new 연산자로 생성자를 호출 할 수 없도록 막아야 함
- 생성자를 호출할 만큼 객체가 생성되기 때문에
- 생성자 앞에 private를 붙여 줌
- 자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화 함
- 정적 필드도 private 접근 제한자를 붙여서 외부에서 필드값 변경 불가능하게 함
- 대신 외부에서 호출할 수 잇는 정적 메소드인 getInstance()를 선언해 정적 피륻에서 참조하고 있는 자신의 객체를 리턴 해줌
```java
public class 클래스 {
	//정적 필드
	private static 클래스 singleton = new 클래스();
	
	//생성자
	private 클래스() { }
	
	//정적 메소드
	static 클래스 getInstance() {
		return singleton;
	}
}
```
- 외부에서 객체를 얻는 방법은 getInstance() 메소드 호출하는 방법 뿐

## 6.11 fianl 필드와 상수
### 6.11.1 final 필드
final : 초기값이 저장되면 이 값이 최종적인 값이 되어서 프로그램 실행 도중 수정 할 수 없음 <br>
필드 선언 시에 주거나 생성자에서 주는 방법 뿐 <br>

### 6.11.2 상수(static final)
상수(static final) : 불변의 값 <br>
- 객체마다 저장되지 않고, 클래스에만 포함
- 한번 초기값이 저장되면 변경 불가능


## 6.12 패키지
패키지 : 클래스를 저장 관리, 파일 시스템의 폴더
- 클래스를 유일하게 만들어주는 식별자 역할
- 클래스 이름이 동일하더라도 패키지가 다르면 다른 클래스로 인식
- 클래스의 전체이름은 "패키지명 + 클래스명"

## 6.13 접근 제한자
접근 제한자(Access Modifier) : 특정 메소드를 호출 할 수 없도록 제한하거나 객체 생성을 막기 위해 생성자를 호출하지 못하게 하거나 객체의 특정 데이터를 보호하기 위해 해당 필드에 접근하지 못하게 막을 때 사용
- public : 클래스, 필드, 생성자, 메소드   => 모두 접근 가능
- protected : 필드, 생성자, 메소드 	  => 같은 패키지나 자식 클래스만 접근 가능
- default : 클래스, 필드, 생성자, 메소드	=> 같은 패키지에 소속된 클래스만 접근 가능
- private : 필드, 생성자, 메소드 	  => 외부 노출 안 됨

### 6.13.1 클래스의 접근 제한
클래스에 적용 가능한 접근 제한은 public과 default 두가지 뿐

### 6.13.2 생성자의 접근 제한
생성자는 public, private, protected, default 접근 제한을 가짐
- 생성자를 성하지 않으면 컴파일러에 의해 자동으로 기본 생성자가 추가 되고 접근 제한은 클래스의 접근 제한과 동일함

### 6.13.3 필드와 메소드의 접근 제한
필드와 메소드는 public, protected, default, private 접근 제한을 가짐<br>

## 6.14 Getter와 Setter 메소드
- 클래스를 선언할 때는 필드를 private로 선언해서 외부로 보호하고 필드에 대한 setter와 getter 메소드를 작성해 필드값을 안전하게 변경/사용하는 것이 좋음
- 필드 타입이 boolean일 경우 getter는 is로 시작하는 것이 관례

## 6.15 어노테이션
@Annotation
어노테이션 용도<br>
1. 컴파일러에게 코드 문법 에러를 체크하도록 정보 제공
2. 소프트웨어 개발 툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보 제공
3. 실행시 특정 기능을 실행하도록 정보를 제공
