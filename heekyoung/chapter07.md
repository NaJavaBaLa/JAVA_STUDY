# Chatper07. 상속
<hr/>

## 7.1 상속 개념
- 부모 클래스의 멤버를 자식 클래스에게 물려줌
- 잘 개발된 클래스를 재사용해 새로운 클래스를 만들기 때문에 코드의 중복을 줄여줌
- 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속에서 제외
- 부모 클래스와 자식 클래스가 다른 패키지에 존재하면 default 접근 제한을 갖는 필드와 메소드도 상속 대상에서 제외됨


## 7.2 클래스 상속
- 자식이 클래스 선언 할 때 어떤 부모 클래스를 상속 받을 것인지 결정 함
- 다중 상속 허용하지 않음 => extends 뒤에는 하나의 부모 클래스만 가능

```java
class Lion extend Animal{
	//필드
	//생성자
	//메소드
}
```

## 7.3 부모 생성자 호출
- 자식 객체 생성시, 부모 객체가 먼저 생성 후 자식이 생성 됨
- 부모 생성자는 자식 생성자의 맨 첫줄에서 호출 됨 => super();
- super()는 반드시 자식 생성자 첫줄에 와야 함 => 어기면 컴파일 에러

## 7.4 메소드 재정의
### 7.4.1 메소드 재정의(@Override)
- 상속된 메소드의 내용이 자식 클래스에 맞지 않을 경우, 자식클래스에서 동일한 매소드를 재정의하는 것
- 메소드가 오버라이딩 되었으면 부모 객체의 메소드는 숨겨지고 오버라이딩 된 자식 객체의 메소드가 호출됨

*메소드 오버라이딩 규칙 주의
- 부모의 메소드와 동일한 시그너처(리턴 타입, 메소드 이름, 매개 변수 리스트)를 가져야 함
- 접근 제한을 더 강하게 오버라이딩 불가능 => 부모가 public인데 자식이 default나 private 불가능 } 부모가 default인 경우 자식이 default나 public 가능
- 새로운 예외를 throws 못함

### 7.4.2 부모 메소드 호출(super)
- super.부모메소드()를 사용해 부모 메소드에 접근 가능

## 7.5 final 클래스와 final 메소드
### 7.5.1 상속 할 수 없는 final 클래스
- 클래스 선언 시 final 키워드를 class 앞에 붙이면 최종적인 클래스이므로 상속 할 수 없는 클래스가 됨 => 자식 클래스를 만들 수 없어 상속 불가능

### 7.5.2 오버라이딩 할 수 없는 final 메소드
- 메소드 선언시 final을 붙이면 오버라이딩 할 수 없는 메소드가 됨
- 부모 클래스를 상속해서 자식 클래스를 선언할 때 부모 클래스에 선언된 final 메소드는 자식 클래스에서 재정의 불가능

## 7.6 protected 접근 제한자
- 접근 제한이 없지만 다른 패키지에서는 자식 클래스만 접근을 허용 함

## 7.7 타입 변환과 다형성
- 다형성 : 같은 타입이지만 실행 결과가 다양ㅎ나 객체를 이용할 수 있는 성질
- 부모 클래스로 타입 변환을 허용 함 => 부모 타입에 모든 자식 객체가 대입 가능 함

### 7.7.1 자동 타입 변환(Promotion)
- 자동 타입 변환 : 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것

### 7.7.2 필드의 다형성
- 필드의 다형성 : 필드의 타입은 변함 없지만 실행 도중 어떤 객체를 필드로 저장하느냐에 따라 실행 결과가 달라지는 것

### 7.7.3 하나의 배열로 객체 관리

### 7.7.4 매개 변수의 다형성
- 자동 타입 변환은 메소드 호출 할 때에도 많이 발생
- 해당 클래스 객체 뿐만 아니라 자식 객체까지도 매개값으로 사용 가능

### 7.7.5 강제 타입 변환(Casting)
- 강제 타입 변환 : 부모 타입을 자식 타입으로 변환하는 것
- 자식 타입이 부모타입으로 자동 변환한 후, 다시 자식 타입으로 변환 할 때강제 타입 변환 사용 가능
- 자식 타입이 부모타입으로 자동 변환하면, 부모 타입에 선언된 필드와 메소드만 사용 가능함

### 7.7.6 객체 타입 확인(instance of)
- instanceof 연산자 : boolean result =  객체 instanceof 타입
- 매개값의 타입을 조사할 때 주로 사용

## 7.8 추상 클래스
### 7.8.1 추상 클래스의 개념
- 추상(abstract) : 공통되는 특성을 추출한 것
- 추상 클래스 : 클래스들의 공통적인 특성을 추출해서 선언한 클래스
- 추상 클래스와 실체 클래스는 상속 관계 => 추상클래스가 부모, 실체 클래스가 자식
- 추상 클래스는 객체를 직접 생성할 수 없다. => new 연산자 사용해서 인스턴스 생성 불가능

### 7.8.2 추상 클래스의 용도
1. 실체 클래스들의 공통된 필드와 메소드의 이름을 통일할 목적
2. 실체 클래스 작성할 때 시간 절약

### 7.8.3 추상 클래스 선언
- abstract 키워드를 붙여야 함
- new 연산자를 이용해 객체 생성 불가능 => 상속을 통해 자식 클래스만 만들 수 있음
- 추상 클래스도 생성자가 반드시 있어야 함

### 7.8.4 추상 메소드와 오버라이딩
- 추상 클래스에서는 추상 메소드 선언 가능
- 추상 메소드는 추상 클래스에서만 선언 가능
- 메소드 선언부만 있고 실행 내용이 없는 메소드
- 자식 클래스는 반드시 추상 메소드를 재정의(오버라이딩)해서 실행 내용을 작성해야 함
