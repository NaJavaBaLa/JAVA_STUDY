# Chatper12. 멀티 스레드
<hr/>

## 12.1 멀티 스레드 개념
### 12.1.1 프로세스와 스레드
- 프로세스(process) : 운영체제에서 실행 중인 하나의 애플리케이션
- 멀티프로세스는 서로 독립적임 -> 하나의 프로세스에서 오류가 발생해도 다른 프로세스에 영향을 주지 않음
- 멀티 스레드는 하나의 프로세스 내부에 생기기 때문에 하나의 스레드가 예외를 발생시키면 프로세스 자체가 종료될 수 있어 다른 스레드에도 영향을 미침

### 12.1.2 메인 스레드
- 싱글 스레드 애플리케이션에서는 메인 스레드가 종료되면 프로세스도 종료 됨
- 멀티 스레드 애플리케이션에서는 실행 중인 스레드가 하나라도 있다면 프로세스는 종료하지 않음

## 12.2 작업 스레드 생성과 실행
- 작업스레드도 객체로 생성되기 때문에 클래스가 필요함
- java.lang.Thread 클래스를 직접 객체화해서 생성해도 되지만, Thread를 상속해서 하위 클래스를 만들어 생성할 수 있음

### 12.2.1 Thread 클래스로부터 직접 생성
- java.lang.Thread 클래스로부터 작업 스레드 객체를 직접 생성

```java
Thread thread = new Thread(Runnable target);
```

- Runnable은 인터페이스 타입이기 때문에 구현 객체를 만들어 대입해야 함
- 구현 클래스는 Runnable의 run() 메소드를 재정의해서 코드를 작성해야 함
- 코드를 절약하기 위해 Thread 생성자를 호출 할 때 Runnable 익명 객체를 매개값으로 사용할 수 있음

```java
Thread thread = new Thread(new Runnable() {
	public void run() {
		실행할 코드;
	}
};
```

### 12.2.2 Thread 하위 클래스로부텈 생성
- 작업 스레드가 실행할 작업을 Runnable로 만들지 않고 Thread의 하위 클래스로 작업 스레드를 정의하면서 작업 내용을 포함시킬 수 있다.
- Thread 클래스를 상속한 후 run 메소드를 재정의해서 스레드가 실행할 코드를 작성


### 12.2.3 스레드의 이름
- 스레드의 이름을 알고 싶은 경우 : thread.getName();
- 스레드의 이름을 설정하고 싶은 경우 : thread.setName("스레드 이름");

## 12.3 스레드 우선순위
- 멀티스레드는 동시성(Concurrency) 또는 병렬성(Parallelism)으로 실행
- 동시성 : 멀티 작업을 위해 하나의 코어에서 멀티스레드가 번갈아가며 실행하는 성질
- 병렬성 : 멀티 작업을 위해 멀티 코어에서 개별 스레드를 동시에 실행하는 성질
- 스레드 스케쥴링 : 스레드의 개수가 코어의 수보다 많을 경우, 스레드를 어떤 순서에 의해 동시성으로 실행할 것인가를 결정해야 하는 것
- 자바의 스레드 스케쥴링 : 우선순위(Priority) 방식과 순환 할당(Round-robin) 방식을 사용
- 우선순위 방식 : 우선순위가 높은 스레드가 실행 상태를 더 많이 가지도록 스케쥴링 하는 것
- 순환 할당 방식 : 시간 할당량(Time Slice)을 정해서 하나의 스레드를 정해진 시간만큼 실행하고 다시 다른 스레드를 실행하는 방식
- 우선순위 방식은 개발자가 우선 순위 번호를 부여할 수 있기 때문에 제어가 가능하지만 순환 할당 방식은 JVM이 정하기 때문에 코드로 제어할 수 없음
- 우선순위 방식은 1에서부터 10까지 있는데 1이 가장 낮고 10이 가장 높음
- 우선순위를 부여하지 않으면 모든 스레드들은 기본적으로 5의 우선순위를 할당 받는다
- thread.setPriority(우선순위);를 통해 우선순위를 변경
- 우선순위가 높은 스레드가 실행기회를 더 많이 가지기 때문에 우선순위가 낮은 스레드보다 계산 작업을 빨리 끝냄

## 12.4 동기화 메소드와 동기화 블록
### 12.4.1 공유 객체를 사용할 대의 주의할 점
- 멀티스레드 프로그램에서는 스레드들이 객체를 공유해서 작업해야 하는 경우가 있음

### 12.4.2 동기화 메소드 및 동기화 블록
- 스레드가 사용중인 객체를 다른 스레드가 변경할 수 없도록 하려면 스레드 작업이 끝날 때까지 객체에 잠금을 걸어서 다른 스레드가 사용할 수 없도록 해야 함
- 임계 영역(critical section) : 멀티 스레드 프로그램에서 단 하나의 스레드만 실행할 수 있는 코드 영역
=> 동기화(Synchronized) 메소드와 동기화 블록을 제공
- 스레드가 객체 내부의 동기화 메소드 또는 블록에 들어가면 즉시 객체에 잠금을 걸어 다른 스레드가 임계 영역 코드를 실행하지 못하도록 함
- synchronized를 붙이면 동기화 메소드가 됨
- 동기화 메소드는 전체 내용이 임계 영역이므로 스레드가 동기화 메소드를 실행하는 즉시 객체에는 잠금이 일어나고, 스레드가 동기화 메소드 실행을 종료하면 잠금이 풀린다.
- 동기화 블록의 내부코드는 임계 영역이므로 한번에 한 스레드만 실행할 수 있고 다른 스레드는 실행할 수 없음

## 12.5 스레드 상태
- 스레드 일시 정지 상태 : 스레드가 실행할 수 없는 상태
=> WAITING, TIMED_WAITING, BLOCKED

*상태      열거 상수    설명<br> 
객체 생성    NEW       스레드 객체가 생성, 아직 start() 메소드가 호출되지 않은 상태<br>
실행 대기    RUNNABLE   실행 상태로 언제든지 갈 수 있는 상태<br> 
일시 정지    Waiting   다른 스레드가 통지할 때까지 기다리는 상태<br> 
          TIMED_WATITING 주어진 시간동안 기다리는 상태<br> 
          BLOCKED	 사용하고자 하는 객체의 락이 풀릴 때 까지 기다리는 상태<br> 
종료       TERMINATED   실행을 마친 상태


## 12.6 스레드 상태 제어
스레드 상태 제어 : 실행 중인 스레드의 상태를 변경하는 것

### 12.6.1 주어진 시간동안 일시정지(sleep())
- 실행 중인 스레드를 일정 시간 멈추게 하고 싶을 때 사용하는 Thread 클래스의 정적 메소드
- 일시정지 상태에서 interrupt() 메소드가 호출되면 interrupteExcaption이 발생

### 12.6.2 다른 스레드에게 실행 양보(yield())
- 의미없는 반복을 줄이기 위해 다른 스레드에게 실행을 양보하고 자신은 실행 대기 상태롤 가는 메소드
- yield() 메소드를 호출한 스레드는 실행 대기 상태로 돌아가고 동일한 우선순위 또는 높은 우선순위를 갖는 다른 스레드가 실행기회를 가질 수 있음

### 12.6.3 다른 스레드의 종료를 기다림(join())
- 스레드는 다른 스레드와 독립적으로 실행하는 것이 기본이지만 다른 스레드가 종료될 때 가지 기다렸다가 실행하는 경우가 발생할 수도 있음

### 12.6.4 스레드 간 협업(wait(), notify(), notifyAll())
- 두개의 스레드를 번갈아가며 실행해야 할 경우
- 정확한 교대 작업이 필요한 경우, 자신의 작업이 끝나면 상대방 스레드를 일시 정지 상태에서 풀어족, 자신은 일시 정지 상태로 만드는 것
- 공유 객체는 두 스레드가 작업할 내용을 각각 동기화 메소드로 구분해 놓음
- 한 스레드가 작업을 완료하면 notify() 메소드를 호출해서 일시 정지 상태에 있는 다른 스레드를 실행 대기 상태로 만들고 자신은 두번 작업을 하지 않도록 wait() 메소드를 호출해 일시 정지 상태로 만든다.

### 12.6.5 스레드의 안전한 종료(stop 플래그, interrupt())
- 스레드는 자신의 run() 메소드가 모두 실행되면 자동적으로 종료 됨

**Stop 플래그를 이용하는 방법**
- 스레드는 run() 메소드가 끝나면 자동적으로 종료되므로 run()메소드가 정상적으로 종료되도록 유도하는 것이 최선임
- stop 플래그를 이용해 run() 메소드의 종료를 유도

**interrupt()메소드를 이용하는 방법**
- interrupt() 메소드는 스레드가 일시 정지 상태에 있을 때 InterruptedException 예외를 발생시키는 역할
- 스레드가 실행 대기 또는 실행 상태에 있을 때 interrupt() 메소드가 실행되면 즉시 InterruptedException 예외가 발생

## 12.7 데몬 스레드
- 데몬(daemon) 스레드는 주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드
- 스레드가 종료되면 데몬 스레드는 강제적으로 자동 종료 됨
=> 주 스레드의 보조 역할을 수행하므올 주 스레드가 종료되면 데몬 스레드의 존재 의미가 없어지기 때문
- start() 메소드 호출 전에 setDaemon(true)를 호출해야 함
- isDaemon() 메소드의 리턴 값을 조사해 데몬 스레드인지 구별

## 12.8 스레드 그룹
- 스레드 그룹(ThreadGroup) : 관련된 스레드를 묶어서 관리할 목적으로 이용
- JVM이 실행되면 System 스레드 그룹을 만들고, JVM 운영에 필요한 스레드들을 생성해서 system 스레드 그룹에 포함
- 스레드는 반드시 하나의 스레드 그룹에 포함되는데 명시적으로 스레드 그룹을 포함시키지 않으면 기본적으로 자신을 생성한 스레드와 같은 스레드 그룹에 속하게 됨
- 대부분 main 스레드가 생성하므로 기본적으로 main 스레드 그룹에 속함

### 12.8.1 스레드 그룹 이름 얻기

현재 스레드가 속한 스레드 그룹의 이름을 얻고 싶을 때 

```java
ThreadGroup group = Thread.currentThread().getThreadGroup();
String groupName = group.getName();
```

프로세스 내에서 실행하는 모든 스레드에 대한 정보 얻기

```java
Map<Thread, StackTraceElement[]> map = Thread.getAllStackTraces();
```

### 12.8.2 스레드 그룹 생성
- 명시적으로 스레드 그룹 만들기

```java
ThreadGroup tg = new ThreadGroup(String name);
ThreadGroup th = new ThreadGroup(ThreadGroup parent, String name);
```

- 스레드 그룹 생성시 부모 스레드 그룹을 지정하지 않으면 현재 스레드가 속한 그룹의 하위 그룹으로 생성 됨
- 새로운 스레드 그룹 생성 후 이 그룹에 스레드를 포함시키려면 Thread 객체를 생성할 때 생성자 매개값으로 스레드 그룹을 지정하면 됨
- 스레드 그룹을 매개값으로 갖는 Thread 생성자 4가지

```java
Thread t = new Thread(ThreadGroup group,Runnable target);
Thread t = new Thread(ThreadGroup group, Runnable target, String name);
Thread t = new Thread(ThreadGroup group, Runnable target, String name, long stackSize);
Thread t = new Thread(ThreadGroup group, String name);
```

### 12.8.3 스레드 그룹의 일괄 interrupt()
- 스레드 그룹의 interrupt() 메소드는 포함된 모든 스레드의 interrupt()메소드를 내부적으로 호출해줌
- 소속된 스레드의 interrupt() 메소드를 호출만 할 뿐 개별 스레드에서 발생하는 interruptedException에 대한 예외 처리는 하지 않음


## 12.9 스레드풀
- 갑작스런 병렬 작업의 폭증올 인한 스레드의 폭증을 막으려면 스레드풀(ThreadPool)을 사용해야 함
- 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고 작업 큐에 들어오는 작업들을 하나씩 스레드가 맡아 처리함
- 작업 처리가 끝난 스레드는 다시 작업 큐에서 새로운 작업을 가져와 처리
- 자바 스레드 풀 생성을 위해 java.util.concurrent 패키지에서 ExcecutorService 인터페이스와 Executors 클래스를 제공
- Executors의 다양한 정적 메소드를 이용해서 ExecutorService 구현 객체를 만들 수 있는데 이것이 스레드 풀임

### 12.9.1 스레드풀 생성 및 종료
**스레드풀 생성**
- 메소드명(매개변수)     초기 스레드 수    코어 스레드 수    최대 스레드 수
- newChachedThreadPool() 0            0            Integer.Max_VALUE
- newFixedThreadPool(int n Threads) 0     nThreads    nThreads
초기 스레드 수 : ExecutorService 객체가 생성될 대 기본적으로 생성되는 스레드 수<br>
코어 스레드 수 : 스레드 수가 증가된 후 사용되지 않는 스레드를 스레드풀에서 제거할 때 최소한 유지해야 할 스레드 수<br>
최대 스레드 수 : 스레드풀에서 관리하는 최대 스레드 수<br>
<br>
** 스레드풀 종료 **
- 스레드풀의 스레드는 main 스레드가 종료되더라도 작업을 처리하기 위해 계속 실행 상태로 남아있다.
- 애플리케이션을 종료하려면 스레드풀을 종료시켜 스레드들이 종료 상태가 되도록 처리해야 함

### 12.9.2 작업 생성과 처리 요청
**작업 생성**
- 하나의 작업은 Runnable 또는 Callable 구현 클래스로 표현
- Runnable의 run() 메소드는 리턴값이 없고, Callable의 call()메소드는 리턴값이 있음
- call()의 리턴타입은 implements Callable<T>에서 지정한 T 타입임

** 작업 처리 요청 **
- ExecutorSErvice의 작업 큐에 Runnable 또는 Callable 객체를 넣는 행위
- execute()는 작업 처리 결과를 받지 못하고 submit()은 작업 처리 결과를 받을 수 있도록 Future를 리턴
- execute()는 작업 처리 도중 예외가 발생하면 스레드가 종료되고 해당 스레드는 스레드풀에서 제거 됨
=> 스레드풀은 다른 작업 처리를 위해 새로운 스레드를 생성
- submit()은 작업 처리 도중 예외가 발생하더라도 스레드는 종료되지 않고 다음 작업을 위해 재사용 됨

### 12.9.3 블로킹 방식의 작업 완료 통보
- Future 객체는 작업 결과가 아니라 작업이 완료될 때 까지 기다렸다가 최종 결과를 얻는데 사용 됨
=> 지연 완료 객체(pending completion)이라고도 함
- Future의 get() 메소드를 호출하면 스레드가 작업을 완료할 때까지 블로킹되었다가 작업을 완료하면 처리 결과를 리턴함
- 작업을 처리하는 스레드가 작업을 완료하기 전까지는 get()메소드가 블로킹되므로 다른 코드를 실행할 수 없음
- 작업을 취소하고 싶은 경우 cancel() 메소드 호출 할 수 있음
=> 작업이 이미 완료되었거나 어떤 이유로 취소될 수 없다면 cancel() 메소드는 false를 리턴함
- isCancelled() 메소드는 작업이 완료되기 전에 작업이 취소되었을 경우에만 true 리턴
- isDone() 메소드는 정상적, 예외, 취소 등 어떤 이유에서건 작업이 완료되었다면 true 리턴

** 리턴 값이 없는 작업 완료 통보 **
- 리턴 값이 없는 작업일 경우 Runnable 객체로 생성하면 됨
- 결과 값이 없는 작업 처리 요청은 submit(Runnable task) 메소드 이용
=> 결과값이 없는데도 Future 객체를 리턴하는데, 스레드가 작업 처리를 정상적으로 완료했는지 아니면 작업 처리 도중에 예외가 발생했는지 확인하기 위해서임<br>
  정상적으로 완료되었다면 Futuer의 get() 메소드는 null을 리턴하지만 스레드가 작업 처리 도중 interrupt 되면 InterruptException을 발생시키고 작업 처리 도중 예외가 발생하면 ExecutionException을 발생
  
** 리턴 값이 없는 작업 완료 통보 **
- 스레드풀의 스레드가 작업을 완료한 후에 어플리케이션이 처리 결과를 얻어야 된다면 작업 객체를 Callable로 생성하면 됨
- 제네릭 타입 파라미터 T는 call() 메소드가 리턴하는 타입이 되도록 함
- Callable 작업 처리 요청은 submit(Runnable tast) 메소드 호출 하면 됨

** 작업 처리 결과를 외부 객체에 저장 **
- ExecutorService의 submit(Runnable task, V result) 메소드를 이용 => V가 Result 타입이 됨

** 작업 완료 순으로 통보 **
- 작업 처리가 완료된 것만 통보 받는 방법 : CompletionService
- CompletionService는 poll()과 take() 메소드 제공

### 12.9.4 콜 백 방식의 작업 완료 통보
- 콜백(callback) : 어플리케이션이 스레드에게 작업 처리를 요청한 후, 스레드가 작업을 완료하면 특정 메소드를 자동 실행하는 기법
