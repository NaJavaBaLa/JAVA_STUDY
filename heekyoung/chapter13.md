# Chatper13. 제네릭
<hr/>

## 13.1 왜 제네릭을 사용해야 하는가?
제네릭을 사용하는 코드의 이점<br>
**컴파일 시 강한 타입 체크를 할 수 있다**
- 컴파일 시 미리 타입을 강하게 체크해서 에러를 사전에 방지

** 타입 변환(casting)을 제거한다.**

```java
List list = new ArrayList();
list.add("hello");
String str = (String) list.get(0);; //타입 변환을 해야 함
```

요소를 찾아 올 때 반드시 타입 변환을 해야 함

```java
List<String> list = new ArrayList<String()>;
list.add("hello");
String str = list.get(0); //타입 변환을 하지 않음
```

## 13.2 제네릭 타입(class<T>, interface<T>)
- 제네릭 타입 : 파라미터를 가지는 클래스와 인터페이스
- 클래스나 인터페이스 이름 뒤에 <> 부호가 붙고 사이에 타입 파라미터가 위치함


## 13.3 멀티 타입 파라미터(class<K,V,...>, interface<K,V,...>)
- 제네릭 타입은 두 개 이상의 멀티 타입 파라미터 사용 가능 => 콤마로 구분

## 13.4 제네릭 메소드(<T,R> R method(T t))
- 제네릭 메소드는 매개 타입과 리턴 타입으로 타입 파라미터를 갖는 메소드를 말 함

## 13.5 제한된 타입 파라미터(<T extends 최상위타입>)
- 제한된 타입 파라미터를 선언하려면 타입 파라미터 뒤에 extends 키워드를 붙이고 상위 타입을 명시
- 상위 타입은 클래스 인터페이스 둘 다 가능 => 인터페이스라고 implements를 사용하지 않음
- 타입 파라미터에 지정되는 구체적인 타입은 상위 타입이거나 상위 타입의 하위 또는 구현 클래스만 가능

## 13.6 와일드카드 타입(<?>, <? extends ...>, <? super ...>)
- 코드에서 ?는 와일드 카드라고 함
- 제네릭타입<?> : Unbounded Wildcards(제한 없음)
  : 타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있다.
- 제네릭타입<? extends 상위타입> : Upper Bounded Wildcards(상위 클래스 제한)
  : 타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나 하위 타입만 올 수 있다.
- 제네릭타입<? super 하위타입> : Lower Bounded Wildcards(하위 클래스 제한)
  : 타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나 상위 타입이 올 수 있다.
  
## 13.7 제네릭 타입의 상속과 구현
- 제네릭 타입도 부모 클래스가 될 수 있음